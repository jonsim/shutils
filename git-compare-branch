#!/usr/bin/env python
# (c) Copyright 2017 Jonathan Simmonds
"""Script to compare the contents of two git branches."""
import argparse     # ArgumentParser
import subprocess   # call, check_output
import sys          # exit
import re           # match

LOOKBACK_THRESHOLD = 1000

class GitError(RuntimeError):
    """Exception caused by Git not behaving as expected."""
    pass

class TreeError(RuntimeError):
    """Exception caused by the parsed tree structure not looking as expected."""
    pass

class Commit(object):
    """Represents an immutable single commit object.

    Attributes:
        hash:           string sha hash for the commit. Must be unique.
        ihash:          int sha hash for the commit. Must be unique. Must be the
            integer representation of hash.
        parents:        list of string hashes of parent commits.
        children:       list of string hashes of child commits.
        commit_date:    string date the commit was pushed.
        author_name:    string name of commit author.
        author_email:   string e-mail address of commit author.
        subject:        string subject line of the commit.
    """
    def __init__(self, sha, parents, children, commit_date, author_name,
                 author_email, subject):
        """Inits the Commit."""
        self.hash = sha
        self.ihash = int(sha, 16)
        self.parents = parents
        self.children = children
        self.commit_date = commit_date
        self.author_name = author_name
        self.author_email = author_email
        self.subject = subject

    def __str__(self):
        """str cast operator."""
        return '%s %s %s\n%s %s %s %s' % \
            (self.hash, str(self.parents), str(self.children), self.commit_date,
             self.author_name, self.author_email, self.subject)

    def __hash__(self):
        """Hash operator."""
        return self.ihash

    def __cmp__(self, other):
        """Basic comparison operator. Returns < 0 iff self < other"""
        if isinstance(other, self.__class__):
            return self.ihash - other.ihash
        return -1

    def __eq__(self, other):
        """Equality operator."""
        if isinstance(other, self.__class__):
            return self.ihash == other.ihash
        return False

    def __ne__(self, other):
        """Non-equality operator."""
        if isinstance(other, self.__class__):
            return self.ihash != other.ihash
        return False

    def __lt__(self, other):
        """Less than operator."""
        if isinstance(other, self.__class__):
            return self.ihash < other.ihash
        return False

    def __le__(self, other):
        """Less than or equal to operator."""
        if isinstance(other, self.__class__):
            return self.ihash <= other.ihash
        return False

    def __gt__(self, other):
        """Greater than operator."""
        if isinstance(other, self.__class__):
            return self.ihash > other.ihash
        return False

    def __ge__(self, other):
        """Greater than or equal to operator."""
        if isinstance(other, self.__class__):
            return self.ihash >= other.ihash
        return False

    def to_string(self, pretty=False):
        """Retrieves a printable representation of the commit.

        Args:
            pretty: bool True to print a format pleasing to humans, False to
                print the raw hash.

        Returns:
            string: Representation of the commit.
        """
        if pretty:
            return '%s %s' % (self.hash[:7], self.subject)
        return self.hash

class Repo(object):
    """Represents a repository and its associated commit tree.

    Attributes:
        _tree:      dict mapping hashes to commit objects.
        _leaves:    list of hashes of all leaf commits (those who do not have
            children or whose children are not in the tree).
        _root:      the root commit hash (that which does not have parents or
            whose parents are not in the tree). Providing LOOKBACK_THRESHOLD is
            sufficient there cannot be more than one.
        _heads:     dict mapping branch names to hashes.
    """
    def __init__(self):
        """Inits the Repo and sets branch heads."""
        self._assert_is_git_repository()
        self._tree = {}
        self._leaves = []
        self._root = None
        self._heads = self._get_branch_heads()

    def _assert_is_git_repository(self):
        """Assert the script is being run from a git repository. This is
        necessary to build the tree.

        Raises:
            GitError: If the script is not being run from a git repository.
        """
        try:
            subprocess.check_output(['git', 'branch'], stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError:
            raise GitError('Not a git repository: \'.\'')

    def _get_branch_heads(self):
        """Retrieves a dict containing mappings for all local branches.

        Returns:
            dict mapping all (local) branch names to their HEADs.

        Raises:
            GitError: If git show-ref output could not be parsed.
        """
        showref_output = subprocess.check_output(
            ['git', 'show-ref', '--heads',]).strip().split('\n')
        heads = {}
        for line in showref_output:
            parts = line.split(' ')
            if len(parts) != 2:
                raise GitError('Poorly formatted show-ref output found at "%s".'
                               % (line))
            head_hash = parts[0]
            head_ref = parts[1]
            if head_ref.startswith('refs/heads/'):
                branch_name = head_ref[len('refs/heads/'):]
                heads[branch_name] = head_hash
        return heads

    def branch_exists(self, branch_name):
        """Determines whether or not a named branch exists locally.

        Args:
            branch_name:    string name of local branch.

        Returns:
            bool: True if the branch exists locally, False otherwise.
        """
        return branch_name in self._heads

    def get_branch_head(self, branch_name):
        """Retrieves the HEAD commit of a branch.

        Args:
            branch_name:    string name of local branch.

        Returns:
            string: hash of branch HEAD.

        Raises:
            GitError: If the named branch does not exist locally.
        """
        try:
            return self._heads[branch_name]
        except KeyError:
            raise GitError('Branch %s does not exist.' % (branch_name))

    def add(self, start_hash):
        """Reads all local history starting from start_hash into internal tree.

        Reads at most LOOKBACK_THRESHOLD commits. This must be sufficient to
        cover the lifetime of the relevant historical action we are interested
        in. Updates internal data structures.

        Args:
            start_hash: string hash to start reading from.

        Raises:
            GitError: If git rev-list output could not be parsed.
        """
        self._leaves.append(start_hash)
        revlist_output = subprocess.check_output(
            ['git', 'rev-list', '-n', str(LOOKBACK_THRESHOLD), '--full-history',
             '--sparse', '--parents', '--format=%cd%x00%an%x00%ae%x00%s%n',
             '--date-order', start_hash]).strip()
        revlist_entries = revlist_output.split('\n\n')
        for entry in revlist_entries:
            lines = entry.split('\n')
            if len(lines) != 2:
                raise GitError('Poorly formatted rev-list output encountered '
                               'at "%s".' % (entry))
            hashes = lines[0].split(' ')
            descriptions = lines[1].split('\0')
            if len(hashes) < 2 or len(descriptions) != 4:
                raise GitError('Poorly formatted rev-list output encountered '
                               'at "%s".' % (entry))
            sha = hashes[1]
            parent_hashes = hashes[2:]
            commit_date = descriptions[0]
            author_name = descriptions[1]
            author_email = descriptions[2]
            subject = descriptions[3]
            self._tree[sha] = Commit(sha, parent_hashes, [], commit_date,
                                     author_name, author_email, subject)
        self._update_root(revlist_entries[-1].split('\n')[0].split(' ')[1])
        self._update_children()

    def _update_root(self, new_root):
        """Compares new_root with the existing _root commit and updates _root
        with the true root commit.

        Updates internal data structures.

        Args:
            new_root:   string hash of root commit for consideration.

        Raises:
            TreeError: If neither root commit appears more 'correct' than the
                other (either both good or both bad). This will only happen if
                the new root exists on a sub-tree not covered by the original
                root (in which case we don't have much hope of success at all).
        """
        if not new_root:
            return
        if not self._root:
            self._root = new_root
            return
        if new_root == self._root:
            return
        # Does either candidate have any parent commits in the tree?
        old_apc = any([p in self._tree for p in self._tree[self._root].parents])
        new_apc = any([p in self._tree for p in self._tree[new_root].parents])
        if old_apc and not new_apc:
            self._root = new_root
            return
        if new_apc and not old_apc:
            return
        raise TreeError('History was found to be cyclic or non-linear while '
                        'attempting to rebuild tree root. This may mean the '
                        'lookback distance (%d) is insufficient to cover the '
                        'relevant history.' % (LOOKBACK_THRESHOLD))

    def _update_children(self):
        """Updates all commit children attribute.

        This attribute is not set from rev-list and must be manually inferred.
        Updates internal data structures.
        """
        # Clear all children.
        for commit in self._tree.values():
            commit.children = []
        # Write all children.
        for commit in self._tree.values():
            for parent in commit.parents:
                try:
                    self._tree[parent].children.append(commit.hash)
                except KeyError:
                    pass

    def get_commit(self, sha):
        """Retrieves the Commit identified by the given sha.

        Args:
            sha:    string hash for the commit to retrieve.

        Returns:
            Commit: Identified commit, or None if no such commit exists.
        """
        try:
            return self._tree[sha]
        except KeyError:
            return None

    def get_commit_parent(self, commit, parent_num=0):
        """Retrieves the commit's given parent commit.

        Args:
            commit:     Commit object for the commit whose parents to retrieve.
            parent_num: 0-indexed number of parent to request.

        Returns:
            Commit: Commit object of the requested parent.

        Raises:
            TreeError: If the given commit does not exist.
            IndexError: If the given commit does not have enough parents.
        """
        try:
            return self._tree[commit.parents[parent_num]]
        except IndexError:
            raise IndexError('Failed to get parent %d - commit %s only has %d '
                             'parents.' % (parent_num, commit.hash,
                                           len(commit.parents)))
        except KeyError:
            raise TreeError('Cannot find parent commit of %s. This is '
                            'typically caused by the lookback distance '
                            '(%d) being insufficient to cover the relevant '
                            'history.' % (commit.hash, LOOKBACK_THRESHOLD))

    def _walk_tree(self, sha):
        """Walks down the first-parent tree from sha making a list of visits.

        Args:
            sha:    string hash of the commit to start the walk from.

        Returns:
            list of Commit: commit objects of all visited commits.

        Raises:
            TreeError: If the start commit does not exist.
        """
        visits = []
        try:
            commit = self._tree[sha]
        except KeyError:
            raise TreeError('Cannot start walk from non-existant commit %s. '
                            'This is typically caused by the lookback distance '
                            '(%d) being insufficient to cover the relevant '
                            'history.' % (sha, LOOKBACK_THRESHOLD))
        while commit:
            visits.append(commit)
            try:
                commit = self._tree[commit.parents[0]]
            except (KeyError, IndexError):
                commit = None
        return visits

    def find_fork_commit(self, sha_a, sha_b):
        """Retrieves the oldest ancestor commit between two commit histories.

        This takes the linearised history given by the trees starting at leaves
        sha_a (tree A) and sha_b (tree B).

        Args:
            sha_a:  string hash of the first leaf commit to list history from.
            sha_b:  string hash of the second leaf commit to list history from.

        Returns:
            Commit: Commit object of the oldest common ancestor (point before
                tree divergence) which exists in A and B.
            list of Commit: Commit objects for all commits in A but not in B.
            list of Commit: Commit objects for all commits in B but not in A.

        Raises:
            TreeError: If the histories have already diverged before the start
                of the internal tree, or if A and B have never diverged (i.e.
                are identical).
        """
        # Walk down the first-parent tree from both start locations.
        visits_a = self._walk_tree(sha_a)
        visits_b = self._walk_tree(sha_b)
        # We want to know the commit before the earliest difference in the lists
        # (which will by definition be shared).
        if visits_a[-1] != visits_b[-1]:
            raise TreeError('Cannot find a reference point to start looking '
                            'for oldest ancestory from. This is typically '
                            'caused by the lookback distance (%d) being '
                            'insufficient to cover the branch\'s lifetime.'
                            % (LOOKBACK_THRESHOLD))
        ancestor_i = None
        for i in range(-2, -min(len(visits_a), len(visits_b)) - 1, -1):
            if visits_a[i] != visits_b[i]:
                ancestor_i = i+1
        if ancestor_i is None:
            raise TreeError('Histories for %s and %s are identical.'
                            % (sha_a, sha_b))
        a_diffs = [a for a in visits_a if a not in visits_b]
        b_diffs = [b for b in visits_b if b not in visits_a]
        return visits_a[ancestor_i], a_diffs, b_diffs

    def find_merge_commit(self, merged_branch, start_sha, merge_pattern=''):
        """Retrieves the commit at which a branch was merged.

        Args:
            merged_branch:  string name of the merged branch to find.
            start_sha:      string hash of the commit to start searching from.
            merge_pattern:  string pattern of the merge commit message to search
                for. The commit message must start with the given pattern
                (defaults to the empty string), followed by any number of
                characters, followed by the name of the branch. The default git
                merge subject looks like "Merge branch 'branchname'".

        Returns:
            Commit: Commit object of the merge commit.

        Raises:
            TreeError: If start_sha does not exist or no matching merge commit
                could be found.
        """
        try:
            commit = self._tree[start_sha]
        except KeyError:
            raise TreeError('Cannot find merge hash from non-existant commit '
                            '%s. This is typically caused by the lookback '
                            'distance (%d) being insufficient to cover the '
                            'relevant history.' % (start_sha,
                                                   LOOKBACK_THRESHOLD))
        merge_re = re.compile('^%s.*%s' % (merge_pattern, merged_branch))
        while commit:
            if len(commit.parents) > 1 and merge_re.match(commit.subject):
                return commit
            try:
                commit = self._tree[commit.parents[0]]
            except (KeyError, IndexError):
                commit = None
        raise TreeError('Failed to find merge point of %s' % (merged_branch))

    def __str__(self):
        """str cast operator."""
        commits = []
        commits.append('leaves: %s\nroot:   %s' % (str(self._leaves),
                                                   str(self._root)))
        to_walk = self._leaves
        walked = []
        while to_walk:
            next_hash = to_walk.pop()
            if next_hash in self._tree and next_hash not in walked:
                next_commit = self._tree[next_hash]
                commits.append(str(next_commit))
                to_walk += next_commit.parents
            walked.append(next_hash)
        return '\n\n'.join(commits)


def print_summary(branch_a, branch_b, branch_b_exists, fork_commit, merge_commit):
    """Prints a summary about the comparison.

    Args:
        branch_a:           string name of the A branch (that being differed
            to).
        branch_b:           string name of the B branch (that with differences
            on).
        branch_b_exists:    bool, True if branch_b currently exists.
        fork_commit:        Commit object representing the fork point, or None
            if the branches have not forked.
        merge_commit:       Commit object representing the merge point, or None
            if the branches have not merged.
    """
    print 'Summary:'
    if branch_b_exists:
        print '  %s still exists' % (branch_b)
    else:
        print '  %s no longer exists' % (branch_b)
    if merge_commit:
        print '  %s merged into %s at: %s' % (branch_b, branch_a,
                                              merge_commit.hash)
    if fork_commit:
        print '  %s forked from %s at: %s' % (branch_b, branch_a,
                                              fork_commit.hash)

def print_branch_diffs(branch_a, branch_b, b_commits, fork_commit,
                       pretty=False):
    """Prints the differences between two branches.

    Args:
        branch_a:       string name of the A branch (that being differed to).
        branch_b:       string name of the B branch (that with differences on).
        b_commits:      list of Commit objects representing those which appear
            on branch B but not branch A.
        fork_commit:    Commit object representing the fork point.
        pretty:         bool, True to pretty print the commits, false otherwise.
    """
    print 'Commits made on %s but not %s:' % (branch_b, branch_a)
    for commit in b_commits:
        if commit == fork_commit:
            break
        print '  %s' % (commit.to_string(pretty))

def print_lifetime_graph(repo, start_commit, end_commit, pretty=False):
    """Prints the topology graph between two commits.

    Args:
        repo:           The Repo object to use when formatting the output.
        start_commit:   Commit object representing the start point of the graph.
        end_commit:     Commit object representing the end point of the graph.
        pretty:         bool, True to pretty print the commits, false otherwise.
    """
    graph_lines = subprocess.check_output(
        ['git', 'log', '--graph', '--no-color', '--format=%x00%H', '%s~..%s'
         % (start_commit.hash, end_commit.hash)]).strip().split('\n')
    graph_parts = []
    for line in graph_lines:
        parts = line.split('\0', 1)
        graph_parts.append((parts[0].strip(),
                            parts[1].strip() if len(parts) > 1 else ''))
    max_len = max([len(p[0]) for p in graph_parts])
    print 'Graph:'
    for part in graph_parts:
        commit = repo.get_commit(part[1])
        print '  %s  %s' % (part[0].ljust(max_len),
                            commit.to_string(pretty) if commit else part[1])

def print_finger(branch_a, branch_b, b_commits, fork_commit):
    """Prints the list of authors fingered by the commit differences.

    Args:
        branch_a:       string name of the A branch (that being differed to).
        branch_b:       string name of the B branch (that with differences on).
        b_commits:      list of Commit objects representing those which appear
            on branch B but not branch A.
        fork_commit:    Commit object representing the fork point.
    """
    authors = []
    for commit in b_commits:
        if commit == fork_commit:
            break
        authors.append((commit.author_name, commit.author_email))
    print 'Authors of commits on %s but not %s:' % (branch_a, branch_b)
    for author in set(authors):
        print '  %s <%s>' % (author[0], author[1])

def main():
    """Main method."""
    # Handle command line
    parser = argparse.ArgumentParser(description='Finds commits in branch_b '
                                     'which are not in branch_a.')
    parser.add_argument('branch_a',
                        type=str,
                        help='Branch A.')
    parser.add_argument('branch_b',
                        type=str,
                        help='Branch B.')
    parser.add_argument('--pattern',
                        type=str, nargs='?', const='', default='Merge branch',
                        help='The merge commit pattern to identify merge '
                        'commits. Defaults to the standard git merge pattern '
                        '"Merge branch". If using a non-default value, the '
                        'merge commits subject must contain the merged branch '
                        'name somewhere preceding the pattern. It is matched '
                        '"^PATTERN.*BRANCH_NAME.*$".')
    parser.add_argument('--both-ways',
                        dest='both_ways', action='store_true', default=False,
                        help='Print both differences on branch B compared to '
                        'branch A as well as on branch A compared to branch B. '
                        'By default just the differences from B to A are '
                        'printed.')
    parser.add_argument('--pretty',
                        dest='pretty', action='store_true', default=False,
                        help='Print a short hash and the subject for all '
                        'commits. By default just the full hash is printed.')
    parser.add_argument('--summary',
                        dest='summary', action='store_true', default=True,
                        help='Print a summary of the status of each branch and '
                        'their relationship. This is the default.')
    parser.add_argument('--no-summary',
                        dest='summary', action='store_false', default=False,
                        help='Do not print the summary list (see --summary).')
    parser.add_argument('--commits',
                        dest='commits', action='store_true', default=True,
                        help='Print a list of all commits which exist on '
                        'branch B but not branch A. This is the default.')
    parser.add_argument('--no-commits',
                        dest='commits', action='store_false', default=False,
                        help='Do not print the commit list (see --commits).')
    parser.add_argument('--finger',
                        dest='finger', action='store_true', default=False,
                        help='Print a list of all users who have made commits '
                        'on branch B.')
    parser.add_argument('--no-finger',
                        dest='finger', action='store_false', default=True,
                        help='Do not print the finger list (see --finger). '
                        'This is the default.')
    parser.add_argument('--graph',
                        dest='graph', action='store_true', default=False,
                        help='Print a chronological graph of the commits made '
                        'to branches A and B during their lifetime. This only '
                        'has an effect if branch B has been merged into branch '
                        'A, otherwise ignored. Corresponds to the --graph '
                        'option of git log.')
    parser.add_argument('--no-graph',
                        dest='graph', action='store_false', default=True,
                        help='Do not print the commit graph (see --graph). '
                        'This is the default.')
    args = parser.parse_args()

    # Do it.
    try:
        repo = Repo()
    except GitError, ex:
        print 'ERR:', ex
        sys.exit(1)

    branch_a_exists = repo.branch_exists(args.branch_a)
    branch_b_exists = repo.branch_exists(args.branch_b)

    if not branch_a_exists:
        # Branch A doesn't exist.
        print 'ERR: Branch A must always exist.'
        sys.exit(1)

    repo.add(repo.get_branch_head(args.branch_a))

    if branch_b_exists:
        repo.add(repo.get_branch_head(args.branch_b))
        # Both branches exist.
        try:
            start_a = repo.get_branch_head(args.branch_a)
            start_b = repo.get_branch_head(args.branch_b)
            fork_commit, a_commits, b_commits = repo.find_fork_commit(start_a,
                                                                      start_b)
        except (GitError, TreeError), ex:
            print 'ERR:', ex
            sys.exit(1)

        if args.summary:
            print_summary(args.branch_a, args.branch_b, branch_b_exists,
                          fork_commit, None)
        if args.commits:
            print ''
            print_branch_diffs(args.branch_b, args.branch_a, b_commits,
                               fork_commit, args.pretty)
            if args.both_ways:
                print ''
                print_branch_diffs(args.branch_a, args.branch_b, a_commits,
                                   fork_commit, args.pretty)
        if args.finger:
            print ''
            print_finger(args.branch_b, args.branch_a, b_commits, fork_commit)
            if args.both_ways:
                print ''
                print_finger(args.branch_a, args.branch_b, a_commits,
                             fork_commit)
    else:
        # Only branch A exists.
        try:
            start_a = repo.get_branch_head(args.branch_a)
            merge_commit = repo.find_merge_commit(args.branch_b, start_a,
                                                  args.pattern)
            start_a = repo.get_commit_parent(merge_commit, 0).hash
            start_b = repo.get_commit_parent(merge_commit, 1).hash
            fork_commit, a_commits, b_commits = repo.find_fork_commit(start_a,
                                                                      start_b)
        except (GitError, TreeError), ex:
            print 'ERR:', ex
            sys.exit(1)

        if args.summary:
            print_summary(args.branch_a, args.branch_b, branch_b_exists,
                          fork_commit, merge_commit)
        if args.commits:
            print ''
            print_branch_diffs(args.branch_b, args.branch_a, b_commits,
                               fork_commit, args.pretty)
            if args.both_ways:
                print ''
                print_branch_diffs(args.branch_a, args.branch_b, a_commits,
                                   fork_commit, args.pretty)
        if args.finger:
            print ''
            print_finger(args.branch_b, args.branch_a, b_commits, fork_commit)
            if args.both_ways:
                print ''
                print_finger(args.branch_a, args.branch_b, a_commits,
                             fork_commit)
        if args.graph:
            print ''
            print_lifetime_graph(repo, fork_commit, merge_commit, args.pretty)

# Entry point.
if __name__ == "__main__":
    main()
